Preguntas:
1. Explica cómo mejorarías el rendimiento utilizando técnicas de caché de red. ¿Dónde
colocarías estos cachés y por qué?
2. ¿Cómo afecta el protocolo de transporte al rendimiento del streaming de video?
Considera TCP vs UDP y justifica tu elección.
3. Propone una solución usando Anycast para optimizar la entrega de contenido.
¿Cómo funcionaría en este contexto?
4. Desarrolla un modelo simplificado para calcular el efecto de la caché en la reducción
de latencia

1. Explicación sobre el rendimiento utilizando técnicas de caché de red:
Las técnicas de caché de red pueden mejorar el rendimiento al almacenar temporalmente datos solicitados frecuentemente cerca de donde se necesitan. Para mejorar el rendimiento:
Colocaría caches en puntos estratégicos de la red, como en los servidores de aplicación, los balanceadores de carga o incluso en los dispositivos de borde de la red.
Estos cachés reducen la latencia y la carga en los servidores al evitar la recuperación repetida de datos desde fuentes remotas.
2. Impacto del protocolo de transporte en el rendimiento del streaming de video:
TCP es más adecuado para el streaming de video debido a su control de congestión y garantía de entrega de datos en orden. Sin embargo, puede introducir mayor latencia debido a la negociación de conexión y retransmisiones.
UDP puede ser más eficiente para el streaming de video en tiempo real, ya que no tiene control de congestión ni garantía de entrega. Aunque puede perder algunos paquetes, es más rápido y puede ser preferido para aplicaciones sensibles al retraso, como videollamadas.
3. Propuesta de solución utilizando Anycast para optimizar la entrega de contenido:
Anycast puede usarse para optimizar la entrega de contenido al dirigir a los usuarios al servidor más cercano según la topología de la red.

Codigo: 

print("apple")  # type: ignore

import os
import paramiko

def connect_to_router(hostname, username, password):
    """Connects to a network device using SSH.

    Args:
        hostname (str): The hostname or IP address of the router.
        username (str): The username to use for authentication.
        password (str): The password to use for authentication.

    Returns:
        paramiko.SSHClient: A connected SSH client object if successful,
                            otherwise raises an exception.

    Raises:
        ConnectionError: If there's an error connecting to the router.
    """

    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        client.connect(hostname, username=username, password=password)
        return client
    except paramiko.SSHException as e:
        raise ConnectionError(f"Failed to connect to router: {e}") from e

def configure_ipsec_vpn(client, peer_ip, local_network, remote_network, pre_shared_key=None):
    """Configures an IPSec VPN on the router.

    Args:
        client (paramiko.SSHClient): A connected SSH client object.
        peer_ip (str): The IP address of the remote peer.
        local_network (str): The local network subnet in CIDR format.
        remote_network (str): The remote network subnet in CIDR format.
        pre_shared_key (str, optional): The pre-shared key for authentication.
                                        Defaults to None (use environment variable).

    Raises:
        ConnectionError: If there's an error while configuring the VPN.
    """

    if not pre_shared_key:
        pre_shared_key = os.getenv("IPSEC_VPN_PSK")  # Read from environment variable

    commands = [
        'crypto isakmp policy 10',
        'encr aes 256',
        'authentication pre-shared',
        'group 5',
        f'crypto isakmp key {pre_shared_key} address {peer_ip}',
        'crypto ipsec transform-set myset esp-aes 256 esp-sha-hmac',
        'crypto map mymap 10 ipsec-isakmp',
        f'set peer {peer_ip}',
        'set transform-set myset',
        'match address 100',
        f'access-list 100 permit ip {local_network} {remote_network}',
        'interface g0/0',
        'crypto map mymap',
        'end'
    ]

    try:
        for command in commands:
            stdin, stdout, stderr = client.exec_command(command)
            output = stdout.read().decode()
            print(output)  # Print output for debugging or logging

            # Check for errors in the output
            if stderr.read().decode():
                raise ConnectionError(f"Error configuring VPN: {stderr.read().decode()}")

    except ConnectionError as e:
        raise e

    finally:
        client.close()  # Ensure client is closed even on exceptions

# Example usage with user input and environment variable
try:
    hostname = input("Enter router hostname or IP address: ")
    username = input("Enter router username: ")
    password = input("Enter router password: ")

    client = connect_to_router(hostname, username, password)

    # Read pre-shared key from environment variable or prompt user
    pre_shared_key = os.getenv("IPSEC_VPN_PSK")
    if not pre_shared_key:
        pre_shared_key = input("Enter pre-shared key: ")

    local_network = input("Enter local network subnet (CIDR): ")
    remote_network = input("Enter remote network subnet (CIDR): ")

    configure_ipsec_vpn(client, peer_ip, local_network, remote_network, pre_shared_key)
    print("IPSec VPN configuration successful!")

except ConnectionError as e:
    print(f"Error: {e}")
